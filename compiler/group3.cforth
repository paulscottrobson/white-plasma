{ ******************************************************************************************* }
{ *																							* }
{ *								Group 3 Colour Forth words 									* }
{ *																							* }
{ ******************************************************************************************* }

{ *** Subtract from memory *** }

:-! 		swap negate swap +! ;

{ *** Shift. Note right are arithmetic not logical, except >> *** }

:>> 		2/ $7FFF and ;				{ these two imply logical shifts }
:<< 		2* ;

{ *** Stack Operations *** }

:rot >r >r [sysinfo] ! r> r> [sysinfo] @ ; 

:mtemp variable 						{ result of multiply }

{ *** Multiply *** }

:* 0 multResult ! *+ *+ *+ *+ *+ *+ *+ *+ *+ *+ *+ *+ *+ *+ *+ *+  drop drop multResult @ ;

{ *** unsigned division *** }

{ this is okay for casual division but not for high speed division, especially }
{ if the Group 1/2 operators are not optimised. Currently division by zero  }
{ returns $FFFF as the quotient }


:quotient variable 								{ quotient value }
:remainder variable  							{ remainder value }

:/												{ Numerator 2nd,Denominator top }
		0 quotient !
		0 remainder !

		16 for
			remainder @ 2* remainder !			{ shift remainder left}
			over ? drop -if 1 remainder +! then	{ if numerator -ve bump remainder }
			swap 2* swap 						{ shift numerator left }

			quotient @ 2* quotient ! 			{ shift quotient left }
			dup remainder @ swap 
			greaterequal drop drop if	{ if remainder >= denominator }
				dup remainder -! 				{ subtract denominator from remainder }
				1 quotient +! 					{ bump the quotient }
			then 
		next
		drop drop quotient @						
;

:umod 	/ drop remainder @ ;

:_main $ABCD
	41723 1029 / remainder @
$FEDC bye

