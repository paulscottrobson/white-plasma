{ ******************************************************************************************* }
{ *																							* }
{ *								Group 1 Colour Forth words 									* }
{ *																							* }
{ ******************************************************************************************* }

{ It is almost mandatory to convert these to machine code, except for initial }
{ implementation/testing as they will be very slow in general operation }

[nop]		{ stops a word being defined as $8000 in VM. }

{*** Constants ***}

:0			$0	;
:1			$1 	;
:2			$2 	;
:-1			$FFFF ;

{*** Basic stack operations ****}

:dup		[sysinfo] ! [sysinfo] @ [sysinfo] @ ;
:drop 		[sysinfo] ! ;
:swap 		[sysinfo] ! >r [sysinfo] @ r> ;
:over 		>r dup r> swap ;
:nip 		swap drop ;

{*** Bitwise arithemtic ***}

:-		 	dup nand ;
:and 		nand - ;
:+or 		- swap - nand ;
:or 		over over - and >r swap - and r> +or ;

{ *** Simple unary/binary arithmetic and comparisions *** }

:1+ 		1 + ;
:1- 		-1 + ;
:2+ 		2 + ;
:2- 		$FFFE + ;
:negate		- 1+ ;
:2* 		dup + ;

:less		over over negate + $8000 and drop ;			{ Z flag clear if a < b }

{ *** Add to memory *** }

:+! 		dup [sysinfo] ! @ + [sysinfo] @ ! ;

{ *** Exit *** }

:bye 		[halt] ;

{ *** Variable helper *** }

:[variable]	[r>] ;

{ *** multiplier substep *** }

:multResult variable 									{ total goes here }

:*+ 	dup 1 and drop 									{ check bit 0 of 1st item}
		if over multResult +! then 						{ if set, add the 2nd item }
		2/ 												{ shift 1st item right }
		swap 2* swap ;									{ shift 2nd item left }

{ *** for/next helper *** }

:[next] [r>] 											{ return address back }
		r> 1- 											{ get count and dec it }
		if >r 0 ? drop >r ; 							{ if zero,push back -1, set Z }
		1 ? drop drop >r ;								{ otherwise set NZ, don't push }

