{ ******************************************************************************************* }
{ *																							* }
{ *									Console Forth words 									* }
{ *																							* }
{ ******************************************************************************************* }

:xCursor variable 								{ position of writing cursor } 
:yCursor variable

:xSize 		private [sysinfo] 12 + c@ ;			{ screen size }
:ySize 		private [sysinfo] 13 + c@ ;

:*xSize 	xSize * ; 							{ this can be optimised }
												{ e.g. :*xSize 	dup 4* + 4* ; }

{ *** The line where you enter stuff *** }

{ writing to the screen only goes this far, then it clears the screen and returns to the }
{ top, in some ways it resembles a Spectrum with a type in bit and a display bit }

:editEntryLine 
			ySize 4 - ;					

:__moveScreenCursor 							{ move h/w cursor to current position }
			private 
			yCursor @ *xSize xCursor @ + cursor! ;

{ *** Clear Screen *** }

:cls 		ySize *xSize do 1- 32 over screen! dup 0= until drop

{ *** Home cursor *** }

:home 		0 xCursor ! 0 yCursor ! __moveScreenCursor ;

{ *** Basic character out.  *** }

:__emit 	private
			yCursor @ *xSize xCursor @ + screen! 
			1 xCursor +! 	
			xCursor @ xSize <> if ; then 
			0 xCursor ! 1 yCursor +! 
			yCursor @ editEntryLine = if cls then ;

:emit 		__emit __moveScreenCursor ;

{ *** Print Space *** }

:space 		32 emit ;

{ *** Print carriage return *** }

:cr 		do space xCursor @ 0= until ;

{ *** Print tos as a 4 digit hexadecimal number *** }

:__hex1 	private 15 and dup 10 < if 57 + then 9 - emit ;
:__hex2 	private dup 16/ __hex1 __hex1 ;
:u.			space dup 256/ __hex2 __hex2 ;
		
{ *** read key, wait for press. *** }

:getkey do keyboard@ ?dup until ;

:_main $ABCD
	0 256 for dup emit 1+ next drop
	codeptr u.
$FEDC [halt]

