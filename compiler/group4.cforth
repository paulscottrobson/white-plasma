{ ******************************************************************************************* }
{ *																							* }
{ *								Group 4 Colour Forth words 									* }
{ *																							* }
{ ******************************************************************************************* }

{ *** unsigned division *** }

{ this is okay for casual division but not for high speed division, especially }
{  if the Group 1/2 operators are not optimised. Currently division by zero  }
{  returns $FFFF as the quotient }


:quotient variable 								{ quotient value }
:remainder variable  							{ remainder value }

:u/												{ Numerator 2nd,Denominator top }
		0 quotient !
		0 remainder !
		16 for
			remainder @ 2* remainder !			{ shift remainder left}
			over 0< if 1 remainder +! then		{ if numerator -ve bump remainder }
			swap 2* swap 						{ shift numerator left }

			quotient @ 2* quotient ! 			{ shift quotient left }
			dup remainder @ swap >= if			{ if remainder >= denominator }
				dup remainder -! 				{ subtract denominator from remainder }
				1 quotient +! 					{ bump the quotient }
			then 
		next
		drop drop quotient @						
;

:umod 	u/ drop remainder @ ;

{ *** CodePtr equivalents for here. Deliberately not using here *** }

:codeptr 	[sysinfo] 6 + @ ;					{ this is unpaged address in 64k space }

:, 			[sysinfo] 9 + c@ page! 				{ make f@ f! work on this page }
			codeptr ! 							{ store at the code pointer position }
			2 [sysinfo] 6 + +! 					{ bump the code pointer by 2 }
;

:c, 		255 and , -1 [sysinfo] 6 + +! ; 	{ c, is the same but go back one ! }

{ Note: compiler should check reasonable space in current page. This will wrap around. }

{ *** Get token in next word *** }

:token		[r>] dup 2+ >r @ ;

{ *** Macros used in system structures : if..then for..next do..until *** }

{ *** If/Then *** }

:ifLink		variable 							{ if vector goes here. }

:if 		macro 
			token [bz] ,
			codeptr ifLink ! 0 ,
;

:then 		macro
			codeptr ifLink @ - 2- ifLink @ ! 
			0 ifLink ! ;

{ *** Do/Until *** }

:doLink 	variable

:do 		macro 
			codePtr doLink ! ; 

:until 		macro
			token [bz] ,
			doLink @ codePtr - 2- ,
			0 doLink ! ;

{ *** For/Next *** }

:forLink 	variable

:for 		macro 		
			token >r ,
			codePtr forLink ! ; 

:next 		macro	
			token [next] ,
			token [bz] ,
			forLink @ codePtr - 2- ,
			0 forLink ! ;


